// BMLKNN: Blocks for Machine Learning (using KNN model)const ArgumentType = require('../../extension-support/argument-type');const BlockType = require('../../extension-support/block-type');const Cast = require('../../util/cast');const formatMessage = require('format-message');const log = require('../../util/log');const {loadCostume} = require('../../import/load-costume.js');const ml5 = require('ml5');const StageLayering = require('../../engine/stage-layering');const Video = require('../../io/video');//for debug//const StageLayering = require('../../engine/stage-layering');//const vm = require('../../virtual-machine.js');//const base64js = require('base64-js');/** * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI. * @type {string} */// eslint-disable-next-line max-lenconst blockIconURI = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxNC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDQzMzYzKSAgLS0+DQo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPg0KPHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSLjg6zjgqTjg6Tjg7xfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4Ig0KCSB5PSIwcHgiIHdpZHRoPSI0MHB4IiBoZWlnaHQ9IjQwcHgiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgNDAgNDAiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHJlY3QgZmlsbD0iI0ZGRkZGRiIgd2lkdGg9IjQwIiBoZWlnaHQ9IjQwIi8+DQo8cmVjdCB4PSIyIiB5PSIyIiBmaWxsPSIjRjhDNzk3IiBzdHJva2U9IiMxRDIwODgiIHN0cm9rZS13aWR0aD0iMC4yNSIgd2lkdGg9IjM2IiBoZWlnaHQ9IjM2Ii8+DQo8cmVjdCB4PSI3Ljc0MiIgeT0iMi4zOTMiIGZpbGw9Im5vbmUiIHdpZHRoPSIyNS42MjkiIGhlaWdodD0iMTIuMDY0Ii8+DQo8dGV4dCB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDcuNzQxNyAxMi43MTc4KSIgZmlsbD0iIzE3MkE4OCIgZm9udC1mYW1pbHk9IidHZW5TaGluR290aGljLVAtTWVkaXVtJyIgZm9udC1zaXplPSIxMiI+Qk1MPC90ZXh0Pg0KPHJlY3QgeD0iMi43OSIgeT0iMTUuNjY3IiBmaWxsPSJub25lIiB3aWR0aD0iMzUuNTMyIiBoZWlnaHQ9IjI2LjA2Ii8+DQo8dGV4dCB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDAuNjYzMSAzNC41OTM4KSI+PHRzcGFuIHg9IjAiIHk9IjAiIGZpbGw9IiMxNzJBODgiIGZvbnQtZmFtaWx5PSInR2VuU2hpbkdvdGhpYy1QLU1lZGl1bSciIGZvbnQtc2l6ZT0iMjIiIGxldHRlci1zcGFjaW5nPSItMyI+SzwvdHNwYW4+PHRzcGFuIHg9IjExLjMzOSIgeT0iMCIgZmlsbD0iIzE3MkE4OCIgZm9udC1mYW1pbHk9IidHZW5TaGluR290aGljLVAtTWVkaXVtJyIgZm9udC1zaXplPSIyMiIgbGV0dGVyLXNwYWNpbmc9Ii01Ij5OPC90c3Bhbj48dHNwYW4geD0iMjIuMTIiIHk9IjAiIGZpbGw9IiMxNzJBODgiIGZvbnQtZmFtaWx5PSInR2VuU2hpbkdvdGhpYy1QLU1lZGl1bSciIGZvbnQtc2l6ZT0iMjIiIGxldHRlci1zcGFjaW5nPSItMyI+TjwvdHNwYW4+PC90ZXh0Pg0KPC9zdmc+DQo='/** * Icon svg to be displayed in the category menu, encoded as a data URI. * @type {string} */// eslint-disable-next-line max-lenconst menuIconURI = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxNC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDQzMzYzKSAgLS0+DQo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPg0KPHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSLjg6zjgqTjg6Tjg7xfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4Ig0KCSB5PSIwcHgiIHdpZHRoPSI0MHB4IiBoZWlnaHQ9IjQwcHgiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgNDAgNDAiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHJlY3QgZmlsbD0iI0ZGRkZGRiIgd2lkdGg9IjQwIiBoZWlnaHQ9IjQwIi8+DQo8cmVjdCB4PSIyIiB5PSIyIiBmaWxsPSIjRjhDNzk3IiBzdHJva2U9IiMxRDIwODgiIHN0cm9rZS13aWR0aD0iMC4yNSIgd2lkdGg9IjM2IiBoZWlnaHQ9IjM2Ii8+DQo8cmVjdCB4PSI3Ljc0MiIgeT0iMi4zOTMiIGZpbGw9Im5vbmUiIHdpZHRoPSIyNS42MjkiIGhlaWdodD0iMTIuMDY0Ii8+DQo8dGV4dCB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDcuNzQxNyAxMi43MTc4KSIgZmlsbD0iIzE3MkE4OCIgZm9udC1mYW1pbHk9IidHZW5TaGluR290aGljLVAtTWVkaXVtJyIgZm9udC1zaXplPSIxMiI+Qk1MPC90ZXh0Pg0KPHJlY3QgeD0iMi43OSIgeT0iMTUuNjY3IiBmaWxsPSJub25lIiB3aWR0aD0iMzUuNTMyIiBoZWlnaHQ9IjI2LjA2Ii8+DQo8dGV4dCB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDAuNjYzMSAzNC41OTM4KSI+PHRzcGFuIHg9IjAiIHk9IjAiIGZpbGw9IiMxNzJBODgiIGZvbnQtZmFtaWx5PSInR2VuU2hpbkdvdGhpYy1QLU1lZGl1bSciIGZvbnQtc2l6ZT0iMjIiIGxldHRlci1zcGFjaW5nPSItMyI+SzwvdHNwYW4+PHRzcGFuIHg9IjExLjMzOSIgeT0iMCIgZmlsbD0iIzE3MkE4OCIgZm9udC1mYW1pbHk9IidHZW5TaGluR290aGljLVAtTWVkaXVtJyIgZm9udC1zaXplPSIyMiIgbGV0dGVyLXNwYWNpbmc9Ii01Ij5OPC90c3Bhbj48dHNwYW4geD0iMjIuMTIiIHk9IjAiIGZpbGw9IiMxNzJBODgiIGZvbnQtZmFtaWx5PSInR2VuU2hpbkdvdGhpYy1QLU1lZGl1bSciIGZvbnQtc2l6ZT0iMjIiIGxldHRlci1zcGFjaW5nPSItMyI+TjwvdHNwYW4+PC90ZXh0Pg0KPC9zdmc+DQo='/** * Status of the video camera. * @readonly * @enum {string} */const VideoState = {    /** Video off **/    OFF: 'off',    /** Video on **/    ON: 'on'};/** * Status of the classification. */const WorkingState = {    /** Results waiting **/    NOTYET: 'notyet',     /** Normal status (Not inquiring) **/    DONE: 'done',     /** Error **/    ERROR: 'error', };/** * image pixcel size */const imageSizeW = 224;const imageSizeH = 224;/** * Class for the new blocks in Scratch 3.0 * @param {Runtime} runtime - the runtime instantiating this block package. * @constructor */class Scratch3_BMLKNN {    constructor (runtime) {        /**         * The runtime instantiating this block package.         * @type {Runtime}         */        this.runtime = runtime;//this.script = document.createElement('script');//this.script.type = 'text/javascript';//this.script.src = 'https://unpkg.com/ml5@0.3.1/dist/ml5.min.js';////document.body.appendChild(this.script);//const firstScript = document.getElementByTagName('script')[0];//firstScript.parentNode.insertBefore(script, firstScript);        /**	 * ML5 only support the MobileNet model for the transfer learning.	 * @type {Mobilenet}	 */        this.featureExtractor = ml5.featureExtractor('MobileNet', () => {});        /**	 * Set the Mobilenet model as classifier (or regressor)	 */        this.classifier = ml5.KNNClassifier();        /**	 *  Loss value of Machine Learning	 */        this.loss = 0;        /**	 * Learning status	 *   NOTYET: not yet learned	 *   DONE  : finished learning	 *   ERROR : not defined	 */        this.learningStatus = WorkingState.NOTYET;        /**	 * netowrk parameters	 *	 */        this.options = {            version: 1,               // MobileNet version            alpha: 0.25,              // MobileNet alpha param            topk: 3,              // Number of returned classes (top             learningRate: 0.0001,            hiddenUnits: 100,            epochs: 20,            numLabels: 2,            batchSize: 0.4,            layer: 'conv_pw_13_relu',	};            /**         * The latest clussification result.         * @type {number}         */        this.classResult = '0';        /**         * The latest classification result.         * @type {number}         */        this.classConfidence = 0;        /**         * Classification Status	 *   NOTYET: not classified 	 *   DONE  : already classified	 *   ERROR : classification error         */        this.classifiedStatus = WorkingState.NOTYET;        /**         * current video status	 *   ON : video on	 *   OFF: video off	 */        //this.currentVideo = VideoState.OFF;        /**         * video flipping	 */        //this.videoFlip = VideoState.OFF;        /**         * Photo frame (border) skinId	 */        this.photoFrameskinId = -1;    }    /**     * @returns {object} metadata for this extension and its blocks.     *     */    getInfo () {        return {            id: 'bmlknn',                // The name of this extension (used as a name space)            color1:'#d2b48c',            color2:'#d2b48c',            name: 'Classifier using KNN model',    // Human readable name            menuIconURI: menuIconURI,            blockIconURI: blockIconURI,            // define of blocks            blocks: [                {                    opcode: 'videoCamera',                    blockType: BlockType.COMMAND,                    text: 'video [VIDEO_STATE] : flip [FLIP_STATE]',                    arguments: {                        VIDEO_STATE: {                            type: ArgumentType.NUMBER,                            menu: 'VIDEO_STATE',                            defaultValue: VideoState.ON                        },                        FLIP_STATE: {                            type: ArgumentType.NUMBER,                            menu: 'FLIP_STATE',                            defaultValue: VideoState.OFF                        }                    }                },                {                    opcode: 'photo',                    blockType: BlockType.COMMAND,                    text: 'photo [SPRITE_ID]',                    arguments: {                        SPRITE_ID: {                            type: ArgumentType.STRING,                            menu: 'SPRITE_ID',                            defaultValue: 'Choose Sprite'                        },                    }                },                {                    opcode: 'addImages',                    blockType: BlockType.COMMAND,                },                {                    opcode: 'classify',                    blockType: BlockType.COMMAND,                    text: 'classify',                },                {                    opcode: 'classifiedResult',                    blockType: BlockType.REPORTER,                    text: 'classifiedResult',                },                {                    opcode: 'classifiedConfidence',                    blockType: BlockType.REPORTER,                    text: 'classifiedConficence',                },                {                    opcode: 'saveNetwork',                    blockType: BlockType.COMMAND,                    text: 'save network',                },                {                    opcode: 'loadNetwork',                    blockType: BlockType.COMMAND,                    text: 'load network',                },            ],            menus: {                VIDEO_STATE:{                    items: ['on', 'off']                },                FLIP_STATE:{                    items: ['on', 'off']                },                OPTIONS:{                    items: ['version',                             'alpha',                             'topk',                             'learningRate',                             'hiddenUnits',                             'epochs',                             'numLabels',                             'batchSize',                             'layer']                },                SPRITE_ID:{                    items:()=>{                        sprites = [];                        for(let i=0; i<this.runtime.targets.length; i++) {                            const target = this.runtime.targets[i];                            if (target.isSprite()){                                let work = [];                                work[0] = target.getName();                                work[1] = target.id;                                sprites[sprites.length] = work;			    }			}                        if(sprites.length == 0) {                            sprites[0] = ['Nan', 'Nan'];			}                        return sprites;                    }                }            }        };    }    videoCamera (args) {        const state = args.VIDEO_STATE;        const flip = args.FLIP_STATE;        if(state == VideoState.ON){            // enable video            this.runtime.ioDevices.video.enableVideo();            this.runtime.ioDevices.video.mirror = (flip == VideoState.ON);	    //this.currentVideo = VideoState.ON;            // draw photo frame (border)            const videoFrameCanvas = document.createElement('canvas');            videoFrameCanvas.width = 480;            videoFrameCanvas.height = 360;            ctx = videoFrameCanvas.getContext('2d');            ctx.lineWidth = 3.0;            ctx.strokeStyle = 'rgb(225,0,0)';            ctx.strokeRect(Math.abs(videoFrameCanvas.width - videoFrameCanvas.height)/2, 0, 360, 360);            this.photoFrameskinId = this.runtime.renderer.createBitmapSkin(videoFrameCanvas, 1);            renderId = this.runtime.renderer.createDrawable(StageLayering.PEN_LAYER);            this.runtime.renderer.updateDrawableProperties(renderId, {skinId: this.photoFrameskinId});        } else {            // clear photo frame (border)            if(this.photoFrameskinId >= 0) {                this.runtime.renderer.destroySkin(this.photoFrameskinId);                this.runtime.requestRedraw();	    }            // disable video            this.runtime.ioDevices.video.disableVideo();	    //this.currentVideo = VideoState.OFF;        }    }    photo(args) {        if (args.SPRITE_ID == 'Nan' || args.SPRITE_ID == 'Choose Sprite') {            console.log('photo args:'+args.SPRITE_ID);            return ;        }        const frameCanvas = this.runtime.ioDevices.video.getFrame({ format:'canvas', dimensions:[480,360]});        // image creation        const canvas = document.createElement('canvas');        canvas.width = imageSizeW*2;        canvas.height = imageSizeH*2;        const ctx = canvas.getContext('2d');        if(frameCanvas.width > frameCanvas.height){            const del = frameCanvas.width - frameCanvas.height;            ctx.drawImage(frameCanvas, del/2, 0, frameCanvas.height, frameCanvas.height, 0, 0, imageSizeW*2, imageSizeH*2);	} else {            const del = frameCanvas.height - frameCanvas.width;            ctx.drawImage(frameCanvas, 0, del/2, frameCanvas.width, frameCanvas.width, 0, 0, imageSizeW*2, imageSizeH*2);	}        // create URL, then add the image to a Sprite        const img = new Image();        img.onload = () => {            const datauri = canvas.toDataURL();            this.addImagesToCostume(args.SPRITE_ID, datauri);	}        img.src = canvas.toDataURL();    }    addImagesToCostume(spriteId, data) {        // Create Uint8Array data to store in the Scratch storage        const raw = window.atob(data.replace('data:image/png;base64,',''));        const assetData = new Uint8Array(new ArrayBuffer(raw.length));        for(let i = 0; i<raw.length; i++) {            assetData[i] = raw.charCodeAt(i);	}        // Create Asset data        const storage = this.runtime.storage;        const asset = storage.createAsset(            storage.AssetType.ImageBitmap,             storage.DataFormat.PNG,             assetData,            null,            true	);        // Create costume object        const now = Date.now();  // Use date and time as a file name        const costume = {            name: String(now),            dataFormat: storage.DataFormat.PNG,            asset: asset,            md5: `${asset.assetId}.${storage.DataFormat.PNG}`,            assetId: asset.assetId        };        // Initialize a costume from an asset in the loadCostume function        // then add the costume to the target.        const target = this.runtime.getTargetById(spriteId);        loadCostume(costume.md5, costume, this.runtime, 3).then(()=>{            target.addCostume(costume);            target.setCostume(target.getCostumes().length - 1);            this.runtime.emitProjectChanged();	});    }    setOption (args) {        const key = Cast.toString(args.OPTIONS);        switch(key) {            case 'alpha':            case 'layer':                const strVal = Cast.toString(args.VALUE);                this.options[key] = strVal;                break;            default:                const numVal = Cast.toNumber(args.VALUE);                this.options[key] = numVal;                break;        };    }/*    initNetwork () {        // create a new network        this.featureExtractor = ml5.featureExtractor('MobileNet', this.options , () => {});        this.classifier = this.featureExtractor.classification();        this.learningStatus = WorkingState.NOTYET;    }*/    addImages () {        this.learningStatus = WorkingState.NOTYET;        // Get images from costume and set them to classifier        for(let i=0; i<this.runtime.targets.length; i++){            // for each sprite            const target = this.runtime.targets[i];            if (target.isSprite()){                // get costumes                const costumes = target.getCostumes()                let n = 0;                // for each costume, get URL from asset                 const costumeUrl = [];                for(let j=0; j<costumes.length; j++){                    const dataFormat = costumes[j].dataFormat;                    if(dataFormat == 'jpg' || dataFormat == 'png') {                        costumeUrl[n] = costumes[j].asset.encodeDataURI();		    } else {                        log.warn('Cannot use this format for classification:'+dataFormat);		    }                    n++;                }                // resize and add images to the classifier.                // assuming the aspect ratio of the costume image is                 // the same as that of the input of the network model.                const adding = [];                for(let j=0; j<costumeUrl.length; j++) {                    const canvas = document.createElement('canvas');                    canvas.width = imageSizeW;                    canvas.height = imageSizeH;                    let ctx = canvas.getContext('2d');                    const img = document.createElement('img');                    img.src = costumeUrl[j];                    ctx.drawImage(img,0,0,img.width,img.height,0,0,imageSizeW,imageSizeH);                    const features = this.featureExtractor.infer(canvas);                    this.classifier.addExample(features, target.getName());		}            }        }        this.learningStatus = WorkingState.DONE;    }    classify(){        //if(this.currentVideo == VideoState.OFF) {        if(!this.runtime.ioDevices.video.provider  || 	   !this.runtime.ioDevices.video.provider.enabled) {            log.warn('video off');            return ;	}        if( this.learningStatus == WorkingState.NOTYET) {            log.warn('not learned');            return ;	}        this.classifiedStatus = WorkingState.NOTYET;        // get image from video frame        const frameCanvas = this.runtime.ioDevices.video.getFrame({ format:'canvas', dimensions:[480,360]});        // risize and trim the image        const canvas = document.createElement('canvas');        canvas.width = imageSizeW;        canvas.height = imageSizeH;        const ctx = canvas.getContext('2d');        if(frameCanvas.width > frameCanvas.height){            const del = frameCanvas.width - frameCanvas.height;            ctx.drawImage(frameCanvas, del/2, 0, frameCanvas.height, frameCanvas.height, 0, 0, imageSizeW, imageSizeH);	} else {            const del = frameCanvas.height - frameCanvas.width;            ctx.drawImage(frameCanvas, 0, del/2, frameCanvas.width, frameCanvas.width, 0, 0, imageSizeW, imageSizeH);	}        // draw photo frame (border)        /*        skinId = this.runtime.renderer.createBitmapSkin(canvas, 1);        renderId = this.runtime.renderer.createDrawable(StageLayering.PEN_LAYER);        this.runtime.renderer.updateDrawableProperties(renderId, {skinId: skinId});        */        // classify the image	const features = this.featureExtractor.infer(canvas);        this.classifier.classify( features, (err, result) => {            if(err) {                log.warn('Classification Error:'+err);                this.classifiedStatus = WorkingState.ERROR;	    } else {                log.warn('Classification Result:'+result);                const conf = result.confidencesByLabel;                this.classResult = result.label;                this.classConfidence = conf[result.label];                this.classifiedStatus = WorkingState.DONE;	    }	});    }    classifiedResult(){        if(this.classifiedStatus == WorkingState.DONE) {            return this.classResult;	} else {            return;	}    }    classifiedConfidence(){        if(this.classifiedStatus == WorkingState.DONE) {            return (this.classConfidence*100).toFixed(3);	} else {            return;	}    }    saveNetwork() {        this.classifier.save();    }    loadNetwork() {        this.showOpenFileDialog().then( (files) => {            if (files.length == 1 && files[0].name.includes('.json')) {                console.log(files[0]);                const fr = new FileReader();                fr.onload = () => {                    const data = JSON.parse(fr.result);                    this.classifier.load(data, ()=>{                        this.learningStatus = WorkingState.DONE;                    });		}                fr.readAsText(files[0]);	    } else {                console.log('modelKNN.json is required.');	    }	});    }    showOpenFileDialog() {        return new Promise(resolve => {             const input = document.createElement('input');             input.type = 'file';             input.accept = '.json';             input.onchange = event => { resolve(event.target.files); };             const dummyEvent = document.createEvent('MouseEvents');             dummyEvent.initEvent('click', true, true);             input.dispatchEvent(dummyEvent);    // it does not work on the Safari.        });    }}module.exports = Scratch3_BMLKNN;
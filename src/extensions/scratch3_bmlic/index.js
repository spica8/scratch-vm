// BMLIC: Blocks for Machine Learning (Image Classifier using pre-trained model)const ArgumentType = require('../../extension-support/argument-type');const BlockType = require('../../extension-support/block-type');const Cast = require('../../util/cast');const formatMessage = require('format-message');const log = require('../../util/log');const {loadCostume} = require('../../import/load-costume.js');const ml5 = require('ml5');const StageLayering = require('../../engine/stage-layering');const Video = require('../../io/video');//for debug//const StageLayering = require('../../engine/stage-layering');//const vm = require('../../virtual-machine.js');//const base64js = require('base64-js');/** * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI. * @type {string} */// eslint-disable-next-line max-lenconst blockIconURI = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxNC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDQzMzYzKSAgLS0+DQo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPg0KPHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSLjg6zjgqTjg6Tjg7xfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4Ig0KCSB5PSIwcHgiIHdpZHRoPSI0MHB4IiBoZWlnaHQ9IjQwcHgiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgNDAgNDAiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHJlY3QgZmlsbD0iI0ZGRkZGRiIgd2lkdGg9IjQwIiBoZWlnaHQ9IjQwIi8+DQo8cmVjdCB4PSIyIiB5PSIyIiBmaWxsPSIjQ0FFNEMxIiBzdHJva2U9IiMxRDIwODgiIHN0cm9rZS13aWR0aD0iMC4yNSIgd2lkdGg9IjM2IiBoZWlnaHQ9IjM2Ii8+DQo8cmVjdCB4PSI3Ljc0MiIgeT0iMi4zOTMiIGZpbGw9Im5vbmUiIHdpZHRoPSIyNS42MjkiIGhlaWdodD0iMTIuMDY0Ii8+DQo8dGV4dCB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDcuNzQxNyAxMi43MTc4KSIgZmlsbD0iIzE3MkE4OCIgZm9udC1mYW1pbHk9IidHZW5TaGluR290aGljLVAtTWVkaXVtJyIgZm9udC1zaXplPSIxMiI+Qk1MPC90ZXh0Pg0KPHJlY3QgeD0iNS4xMzQiIHk9IjEwLjMzNCIgZmlsbD0ibm9uZSIgd2lkdGg9IjM1LjUzMiIgaGVpZ2h0PSIyNi4wNTkiLz4NCjx0ZXh0IHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgNS4xMzMzIDM2LjE0NDUpIiBmaWxsPSIjMTcyQTg4IiBmb250LWZhbWlseT0iJ0dlblNoaW5Hb3RoaWMtUC1NZWRpdW0nIiBmb250LXNpemU9IjMwIj5JQzwvdGV4dD4NCjxyZWN0IHg9IjMuODA5IiB5PSIzMC41IiBmaWxsPSJub25lIiB3aWR0aD0iMzMuNDk2IiBoZWlnaHQ9IjcuNSIvPg0KPHRleHQgdHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgMSAzLjgwOTEgMzUuNjYyMSkiIGZpbGw9IiNGRkZGRkYiIGZvbnQtZmFtaWx5PSInR2VuU2hpbkdvdGhpYy1QLU1lZGl1bSciIGZvbnQtc2l6ZT0iNiI+cHJlLXRyYWluZWQ8L3RleHQ+DQo8dGV4dCB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDMuODA5MSAzNS42NjIxKSIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMUQyMDg4IiBzdHJva2Utd2lkdGg9IjAuMSIgZm9udC1mYW1pbHk9IidHZW5TaGluR290aGljLVAtTWVkaXVtJyIgZm9udC1zaXplPSI2Ij5wcmUtdHJhaW5lZDwvdGV4dD4NCjwvc3ZnPg0K'/** * Icon svg to be displayed in the category menu, encoded as a data URI. * @type {string} */// eslint-disable-next-line max-lenconst menuIconURI = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxNC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDQzMzYzKSAgLS0+DQo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPg0KPHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSLjg6zjgqTjg6Tjg7xfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4Ig0KCSB5PSIwcHgiIHdpZHRoPSI0MHB4IiBoZWlnaHQ9IjQwcHgiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgNDAgNDAiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHJlY3QgZmlsbD0iI0ZGRkZGRiIgd2lkdGg9IjQwIiBoZWlnaHQ9IjQwIi8+DQo8cmVjdCB4PSIyIiB5PSIyIiBmaWxsPSIjQ0FFNEMxIiBzdHJva2U9IiMxRDIwODgiIHN0cm9rZS13aWR0aD0iMC4yNSIgd2lkdGg9IjM2IiBoZWlnaHQ9IjM2Ii8+DQo8cmVjdCB4PSI3Ljc0MiIgeT0iMi4zOTMiIGZpbGw9Im5vbmUiIHdpZHRoPSIyNS42MjkiIGhlaWdodD0iMTIuMDY0Ii8+DQo8dGV4dCB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDcuNzQxNyAxMi43MTc4KSIgZmlsbD0iIzE3MkE4OCIgZm9udC1mYW1pbHk9IidHZW5TaGluR290aGljLVAtTWVkaXVtJyIgZm9udC1zaXplPSIxMiI+Qk1MPC90ZXh0Pg0KPHJlY3QgeD0iNS4xMzQiIHk9IjEwLjMzNCIgZmlsbD0ibm9uZSIgd2lkdGg9IjM1LjUzMiIgaGVpZ2h0PSIyNi4wNTkiLz4NCjx0ZXh0IHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgNS4xMzMzIDM2LjE0NDUpIiBmaWxsPSIjMTcyQTg4IiBmb250LWZhbWlseT0iJ0dlblNoaW5Hb3RoaWMtUC1NZWRpdW0nIiBmb250LXNpemU9IjMwIj5JQzwvdGV4dD4NCjxyZWN0IHg9IjMuODA5IiB5PSIzMC41IiBmaWxsPSJub25lIiB3aWR0aD0iMzMuNDk2IiBoZWlnaHQ9IjcuNSIvPg0KPHRleHQgdHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgMSAzLjgwOTEgMzUuNjYyMSkiIGZpbGw9IiNGRkZGRkYiIGZvbnQtZmFtaWx5PSInR2VuU2hpbkdvdGhpYy1QLU1lZGl1bSciIGZvbnQtc2l6ZT0iNiI+cHJlLXRyYWluZWQ8L3RleHQ+DQo8dGV4dCB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDMuODA5MSAzNS42NjIxKSIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMUQyMDg4IiBzdHJva2Utd2lkdGg9IjAuMSIgZm9udC1mYW1pbHk9IidHZW5TaGluR290aGljLVAtTWVkaXVtJyIgZm9udC1zaXplPSI2Ij5wcmUtdHJhaW5lZDwvdGV4dD4NCjwvc3ZnPg0K'/** * Status of the video camera. * @readonly * @enum {string} */const VideoState = {    /** Video off **/    OFF: 'off',    /** Video on **/    ON: 'on'};/** * Status of the classification. */const WorkingState = {    /** Results waiting **/    NOTYET: 'notyet',     /** Normal status (Not inquiring) **/    DONE: 'done',     /** Error **/    ERROR: 'error', };/** * image pixcel size */const imageSizeW = 224;const imageSizeH = 224;/** * Class for the new blocks in Scratch 3.0 * @param {Runtime} runtime - the runtime instantiating this block package. * @constructor */class Scratch3_BMLIC {    constructor (runtime) {        /**         * The runtime instantiating this block package.         * @type {Runtime}         */        this.runtime = runtime;        /**	 * Set the Mobilenet model as classifier (or regressor)	 */        this.classifier = ml5.imageClassifier('MobileNet', {version:1}, () => {});        /**	 * netowrk parameters	 *	 */         /*        this.options = {            version: 1,               // MobileNet version            alpha: 0.25,              // MobileNet alpha param            topk: 3,              // Number of returned classes (top             learningRate: 0.0001,            hiddenUnits: 100,            epochs: 20,            numLabels: 2,            batchSize: 0.4,            layer: 'conv_pw_13_relu',	};	*/            /**         * The latest clussification result.         * @type {number}         */        this.classResult = '0';        /**         * The latest classification result.         * @type {number}         */        this.classConfidence = 0;        /**         * Classification Status	 *   NOTYET: not classified 	 *   DONE  : already classified	 *   ERROR : classification error         */        this.classifiedStatus = WorkingState.NOTYET;        /**         * current video status	 *   ON : video on	 *   OFF: video off	 */        //this.currentVideo = VideoState.OFF;        /**         * video flipping	 */        //this.videoFlip = VideoState.OFF;        /**         * Photo frame (border) skinId	 */        this.photoFrameskinId = -1;    }    /**     * @returns {object} metadata for this extension and its blocks.     *     */    getInfo () {        return {            id: 'bmlic',                // The name of this extension (used as a name space)            color1:'#8fbc8f',            color2:'#8fbc8f',            name: 'Image Classifier using pre-trained model',    // Human readable name            menuIconURI: menuIconURI,            blockIconURI: blockIconURI,            // define of blocks            blocks: [                {                    opcode: 'videoCamera',                    blockType: BlockType.COMMAND,                    text: 'video [VIDEO_STATE] : flip [FLIP_STATE]',                    arguments: {                        VIDEO_STATE: {                            type: ArgumentType.NUMBER,                            menu: 'VIDEO_STATE',                            defaultValue: VideoState.ON                        },                        FLIP_STATE: {                            type: ArgumentType.NUMBER,                            menu: 'FLIP_STATE',                            defaultValue: VideoState.OFF                        }                    }                },                {                    opcode: 'classify',                    blockType: BlockType.COMMAND,                    text: 'classify',                },                {                    opcode: 'classifiedResult',                    blockType: BlockType.REPORTER,                    text: 'classifiedResult',                },                {                    opcode: 'classifiedConfidence',                    blockType: BlockType.REPORTER,                    text: 'classifiedConfidence',                },            ],            menus: {                VIDEO_STATE:{                    items: ['on', 'off']                },                FLIP_STATE:{                    items: ['on', 'off']                },                OPTIONS:{                    items: ['version',                             'alpha',                             'topk',                             'learningRate',                             'hiddenUnits',                             'epochs',                             'numLabels',                             'batchSize',                             'layer']                },                SPRITE_ID:{                    items:()=>{                        sprites = [];                        for(let i=0; i<this.runtime.targets.length; i++) {                            const target = this.runtime.targets[i];                            if (target.isSprite()){                                let work = [];                                work[0] = target.getName();                                work[1] = target.id;                                sprites[sprites.length] = work;			    }			}                        if(sprites.length == 0) {                            sprites[0] = ['Nan', 'Nan'];			}                        return sprites;                    }                }            }        };    }    videoCamera (args) {        const state = args.VIDEO_STATE;        const flip = args.FLIP_STATE;        if(state == VideoState.ON){            // enable video            this.runtime.ioDevices.video.enableVideo();            this.runtime.ioDevices.video.mirror = (flip == VideoState.ON);	    //this.currentVideo = VideoState.ON;            // draw photo frame (border)            const videoFrameCanvas = document.createElement('canvas');            videoFrameCanvas.width = 480;            videoFrameCanvas.height = 360;            ctx = videoFrameCanvas.getContext('2d');            ctx.lineWidth = 3.0;            ctx.strokeStyle = 'rgb(225,0,0)';            ctx.strokeRect(Math.abs(videoFrameCanvas.width - videoFrameCanvas.height)/2, 0, 360, 360);            this.photoFrameskinId = this.runtime.renderer.createBitmapSkin(videoFrameCanvas, 1);            renderId = this.runtime.renderer.createDrawable(StageLayering.PEN_LAYER);            this.runtime.renderer.updateDrawableProperties(renderId, {skinId: this.photoFrameskinId});        } else {            // clear photo frame (border)            if(this.photoFrameskinId >= 0) {                this.runtime.renderer.destroySkin(this.photoFrameskinId);                this.runtime.requestRedraw();	    }            // disable video            this.runtime.ioDevices.video.disableVideo();	    //this.currentVideo = VideoState.OFF;        }    }/*    setOption (args) {        const key = Cast.toString(args.OPTIONS);        switch(key) {            case 'alpha':            case 'layer':                const strVal = Cast.toString(args.VALUE);                this.options[key] = strVal;                break;            default:                const numVal = Cast.toNumber(args.VALUE);                this.options[key] = numVal;                break;        };    }    initNetwork () {        // create a new network        //this.classifier = ml5.imageClassifier('MobileNet', {version:1}, () => {});    }*/    classify(){        //if(this.currentVideo == VideoState.OFF) {        if( !this.runtime.ioDevices.video.provider || 	    !this.runtime.ioDevices.video.provider.enabled){            log.warn('video off');            return ;	}        this.classifiedStatus = WorkingState.NOTYET;        // get image from video frame        const frameCanvas = this.runtime.ioDevices.video.getFrame({ format:'canvas', dimensions:[480,360]});        // risize and trim the image        const canvas = document.createElement('canvas');        canvas.width = imageSizeW;        canvas.height = imageSizeH;        const ctx = canvas.getContext('2d');        if(frameCanvas.width > frameCanvas.height){            const del = frameCanvas.width - frameCanvas.height;            ctx.drawImage(frameCanvas, del/2, 0, frameCanvas.height, frameCanvas.height, 0, 0, imageSizeW, imageSizeH);	} else {            const del = frameCanvas.height - frameCanvas.width;            ctx.drawImage(frameCanvas, 0, del/2, frameCanvas.width, frameCanvas.width, 0, 0, imageSizeW, imageSizeH);	}        // draw photo frame (border)        /*        skinId = this.runtime.renderer.createBitmapSkin(canvas, 1);        renderId = this.runtime.renderer.createDrawable(StageLayering.PEN_LAYER);        this.runtime.renderer.updateDrawableProperties(renderId, {skinId: skinId});        */        // classify the image        this.classifier.classify( canvas, 1, (err, results) => {            if(err) {                log.warn('Classification Error in BMLIC:'+err);                this.classifiedStatus = WorkingState.ERROR;	    } else {                log.warn('Classification Result in BMLIC:'+results);                this.classResult = results[0].label;                this.classConfidence = results[0].confidence;                this.classifiedStatus = WorkingState.DONE;	    }	});    }    classifiedResult(){        if(this.classifiedStatus == WorkingState.DONE) {            return this.classResult;	} else {            return;	}    }    classifiedConfidence(){        if(this.classifiedStatus == WorkingState.DONE) {            return (this.classConfidence*100).toFixed(3);	} else {            return;	}    }}module.exports = Scratch3_BMLIC;